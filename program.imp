# Programa de prueba grande para IMP (comentarios con #)

# Inicializaciones
x := 0;
y := 1;
i := 0;
n := 30;
sum := 0;
prod := 1;

# Acumulados y producto tipo factorial
while i <= n do
(
  sum := sum + i;
  prod := prod * (i + 1);

  if (i = 0) then skip else x := x + 1;

  if (i <= 10) then
    ( y := y + i; z := (y * 2) - (x + 3) )
  else
    ( y := y - 1; z := z + y * (x - 2) );

  i := i + 1
);

# Fibonacci
a := 0; b := 1; k := 0;
while k <= 20 do
(
  t := a + b;
  a := b;
  b := t;
  k := k + 1
);

# Condicionales anidados
p := 1; q := 2; r := 3; s := 4;
if ( (p + q) <= (r * s) ) then
(
  u := (p + q + r + s);
  if (u = 10) then
    ( flag := true; w := 0 )
  else
    ( flag := false; w := 1 )
)
else
(
  u := (p * q) - (r + s);
  if (u <= 0) then
    ( flag := false; w := (0 - u) )
  else
    ( flag := true; w := u )
);

# Lógica booleana
ok := true;
ok := ok and (not false) and (x <= y) and (a <= b) and (u = w);

# Bucle doble
c := 0; d := 10;
while c <= d do
(
  # bucle interno
  j := 0;
  while j <= c do
  (
    sum := sum + (c * j);
    j := j + 1
  );
  c := c + 1
);

# Paréntesis y aritmética
m := (((((1 + 2) * 3) - 4) * (5 + 6)) - (7 * (8 - 9))) + 10;

# Maximal munch con espacios
   espacio   :=    1   +   2   *  3   -  4   ;

# Varios ; consecutivos
skip;;;skip; ;  ;  skip;

# Caso más complejo
if ( (x + y + z) <= (a * b * c) ) then
(
  alpha := x * (y + z) - a;
  beta  := (b * c) - (x + y);
  gamma := (alpha + beta) * (w + 1)
)
else
(
  alpha := (a + b + c) - (x * y);
  beta  := (w * z) - (a - b);
  gamma := (alpha * beta) - (u * v)
);

# Final
result := sum + prod + a + b + u + w + alpha + beta + gamma;
